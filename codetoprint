void insertNode(Node** head, int data) {
    // 1. Create a new Node
    Node* newNode = new Node;
    newNode->data = data;
    newNode->next = nullptr; 

    // 2. If the list is empty, make the new node the head
    if (*head == nullptr) {
        *head = newNode;
        return;
    }

    // 3. Traverse to the last node
    Node* current = *head;
    while (current->next != nullptr) {
        current = current->next;
    }

    // 4. Link the last node to the new node
    current->next = newNode;
}

// 2. deleteSecondLastNode function
void deleteSecondLastNode(Node** head) {
    // Case 1: List is empty or has only one node
    if (*head == nullptr || (*head)->next == nullptr) {
        return;
    }

    // Case 2: List has exactly two nodes (delete the head)
    if ((*head)->next->next == nullptr) {
        Node* temp = *head; 
        *head = (*head)->next; 
        delete temp;
        return;
    }

    // Case 3: List has three or more nodes
    // 'current' will stop at the node *before* the second-to-last node (third-to-last).
    Node* current = *head;
    
    // Check two steps ahead: if 'next->next->next' is nullptr, then 'next->next' is the last node.
    // 'current->next' is the second-to-last node.
    while (current->next->next->next != nullptr) {
        current = current->next;
    }
    
    // 'nodeToDelete' is the second-to-last node
    Node* nodeToDelete = current->next;
    
    // Skip the nodeToDelete
    current->next = nodeToDelete->next; 
    
    // Free the memory
    delete nodeToDelete;
}

// 3. displayLinkedList function
void displayLinkedList(Node* head) {
    Node* current = head;
    while (current != nullptr) {
        std::cout << current->data << " ";
        current = current->next;
    }
    std::cout << std::endl;
}