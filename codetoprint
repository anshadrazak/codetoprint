void deleteSecondLastNode(Node** head) {
    // 1. Handle edge cases where deletion is impossible (0 or 1 node)
    if (*head == nullptr || (*head)->next == nullptr) {
        return;
    }

    // 2. Handle the case where the list has exactly two nodes (delete the head)
    // List: [A] -> [B] -> nullptr. Second-to-last is A (the head).
    if ((*head)->next->next == nullptr) {
        Node* temp = *head; 
        *head = (*head)->next; 
        delete temp;
        return;
    }

    // 3. Handle the general case (3 or more nodes)
    // We need 'current' to stop at the node *before* the second-to-last node.
    // This node is the third-to-last node.
    Node* current = *head;
    
    // Stop when 'current->next->next' is the last node.
    // i.e., current->next->next->next is nullptr.
    while (current->next->next->next != nullptr) {
        current = current->next;
    }
    
    // 'current' is now the 3rd-to-last node.
    // 'nodeToDelete' is the 2nd-to-last node.
    Node* nodeToDelete = current->next;
    
    // Link the 3rd-to-last node to the last node.
    current->next = nodeToDelete->next; 
    
    // Free the memory
    delete nodeToDelete;
}
