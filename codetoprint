#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<int> books(n);
    for (int i = 0; i < n; i++)
        cin >> books[i];

    int x, k;
    cin >> x >> k;

    // Step 1: Binary Search to find the closest position
    int left = 0, right = n - 1, mid;
    while (left <= right) {
        mid = left + (right - left) / 2;
        if (books[mid] == x)
            break;
        else if (books[mid] < x)
            left = mid + 1;
        else
            right = mid - 1;
    }

    // Determine the starting positions
    int l = mid - 1, r = mid + 1;
    if (books[mid] != x) { // Adjust mid if x not found
        if (left >= n) mid = n - 1;
        else if (right < 0) mid = 0;
        else mid = left;
        l = mid - 1;
        r = mid;
    }

    vector<int> result;
    result.push_back(books[mid]);

    // Step 2: Expand around the mid
    while (result.size() < k) {
        if (l >= 0 && r < n) {
            if (abs(books[l] - x) <= abs(books[r] - x))
                result.push_back(books[l--]);
            else
                result.push_back(books[r++]);
        } else if (l >= 0)
            result.push_back(books[l--]);
        else if (r <
